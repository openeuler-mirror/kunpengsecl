/*
kunpengsecl licensed under the Mulan PSL v2.
You can use this software according to the terms and conditions of
the Mulan PSL v2. You may obtain a copy of Mulan PSL v2 at:
    http://license.coscl.org.cn/MulanPSL2
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
See the Mulan PSL v2 for more details.

Author: jiayunhao
Create: 2021-09-17
Description: Define the structure for the TPM operation.
*/

package ractools

import (
	"bytes"
	"crypto"
	"encoding/binary"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os/exec"
	"strings"

	"gitee.com/openeuler/kunpengsecl/attestation/common/cryptotools"
	"gitee.com/openeuler/kunpengsecl/attestation/common/typdefs"
	"gitee.com/openeuler/kunpengsecl/attestation/tee/demo/qca_demo/qapi"
	"github.com/google/go-tpm-tools/simulator"
	"github.com/google/go-tpm/tpm2"
	"github.com/google/go-tpm/tpmutil"
)

const (
	//   on TCG EK Credential Profile For TPM Family 2.0
	//   Level 0 Version 2.4 Revision 3
	//   https://trustedcomputinggroup.org/resource/tcg-ek-credential-profile-for-tpm-family-2-0/
	//      0x01C00002      RSA 2048 EK Certificate
	//      0x01C00003      RSA 2048 EK Nonce
	//      0x01C00004      RSA 2048 EK Template
	//      0x01C0000A      ECC NIST P256 EK Certificate
	//      0x01C0000B      ECC NIST P256 EK Nonce
	//      0x01C0000C      ECC NIST P256 EK Template
	//      0x01C00012      RSA 2048 EK Certificate (H-1)
	//      0x01C00014      ECC NIST P256 EK Certificate (H-2)
	//      0x01C00016      ECC NIST P384 EK Certificate (H-3)
	//      0x01C00018      ECC NIST P512 EK Certificate (H-4)
	//      0x01C0001A      ECC SM2_P256 EK Certificate (H-5)
	//      0x01C0001C      RSA 3072 EK Certificate (H-6)
	//      0x01C0001E      RSA 4096 EK Certificate (H-7)
	IndexRsa2048EKCert     uint32 = 0x01C00002
	IndexRsa2048EKNonce    uint32 = 0x01C00003
	IndexRsa2048EKTemplate uint32 = 0x01C00004
	IndexECCP256EKCert     uint32 = 0x01C0000A
	IndexECCP256EKNonce    uint32 = 0x01C0000B
	IndexECCP256EKTemplate uint32 = 0x01C0000C
	IndexRsa2048EKCertH1   uint32 = 0x01C00012
	IndexECCP256EKCertH2   uint32 = 0x01C00014
	IndexECCP384EKCertH3   uint32 = 0x01C00016
	IndexECCP512EKCertH4   uint32 = 0x01C00018
	IndexSM2P256EKCertH5   uint32 = 0x01C0001A
	IndexRsa3072EKCertH6   uint32 = 0x01C0001C
	IndexRsa4096EKCertH7   uint32 = 0x01C0001E

	tpmDevPath1  = "/dev/tpmrm0"
	tpmDevPath2  = "/dev/tpm0"
	blockSize    = 1024
	constDMIBIOS = `# dmidecode 3.2
Getting SMBIOS data from sysfs.
SMBIOS 2.7 present.

Handle 0x0000, DMI type 0, 24 bytes
BIOS Information
	Vendor: American Megatrends Inc.
	Version: 4.6.5
	Release Date: 09/26/2013
	Address: 0xF0000
	Runtime Size: 64 kB
	ROM Size: 4096 kB
	Characteristics:
		PCI is supported
		BIOS is upgradeable
		BIOS shadowing is allowed
		Boot from CD is supported
		Selectable boot is supported
		EDD is supported
		Print screen service is supported (int 5h)
		8042 keyboard services are supported (int 9h)
		Printer services are supported (int 17h)
		ACPI is supported
		USB legacy is supported
		BIOS boot specification is supported
		Targeted content distribution is supported
		UEFI is supported
	BIOS Revision: 4.6`
	constDMISYSTEM = `# dmidecode 3.2
Getting SMBIOS data from sysfs.
SMBIOS 2.7 present.

Handle 0x0001, DMI type 1, 27 bytes
System Information
	Manufacturer: Hasee Computer
	Product Name: CW35S
	Version: Not Applicable
	Serial Number: Not Applicable
	UUID: f0f59000-7a0a-0000-0000-000000000000
	Wake-up Type: Power Switch
	SKU Number: Not Applicable
	Family: Not Applicable`

	emptyPassword   = ""
	talistpath      = "./talist"
	TestImaLogPath  = "./ascii_runtime_measurements"
	TestBiosLogPath = "./binary_bios_measurements"
	TestSeedPath    = "./simulator_seed"
	ImaLogPath      = "/sys/kernel/security/ima/ascii_runtime_measurements"
	BiosLogPath     = "/sys/kernel/security/tpm0/binary_bios_measurements"
	AlgSM3          = 0x0012
	algSHA1Str      = "sha1"
	algSHA256Str    = "sha256"
	algSHA384Str    = "sha384"
	algSHA512Str    = "sha512"
	algSM3Str       = "sm3"
	strfalse        = "false"
)

var (
	data_len1 int    = 3624
	uuid1     string = "test"
	taReport1        = []byte{
		0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x68, 0x61, 0x6c,
		0x6c, 0x65, 0x6e, 0x67, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x01, 0x9d, 0xc2,
		0x13, 0xcd, 0x5a, 0x40, 0x99, 0xf9, 0x06, 0x34, 0x3d, 0xfb, 0xe6, 0x91, 0x00, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x10, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20,
		0x20, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00,
		0xd8, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x20, 0x00, 0x02, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00, 0x09, 0x00, 0x00, 0x20,
		0x10, 0x0b, 0x00, 0x00, 0x18, 0x03, 0x00, 0x00, 0x09, 0x0b, 0x10, 0xa2, 0xdf, 0x8c, 0xdb, 0xdb,
		0x10, 0x50, 0x96, 0x15, 0xc8, 0x3f, 0x44, 0x7f, 0x35, 0x57, 0x9d, 0x2f, 0xe1, 0xc6, 0x32, 0xc0,
		0x6b, 0xd8, 0xca, 0x8c, 0x74, 0xd0, 0x69, 0xf5, 0x0f, 0x19, 0x52, 0x58, 0xb8, 0x70, 0x28, 0xa6,
		0x2f, 0xb2, 0x9b, 0x1e, 0x9e, 0xf2, 0x21, 0x89, 0x75, 0x30, 0xdc, 0x09, 0x09, 0x94, 0xe3, 0xb1,
		0x7b, 0x23, 0x50, 0x11, 0x7d, 0x25, 0x94, 0x92, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3b, 0x0e, 0xb0, 0x99, 0x8f, 0x39, 0xa7, 0x37,
		0x04, 0x8f, 0x90, 0xb7, 0x62, 0xa1, 0xfe, 0xe4, 0x55, 0x90, 0xba, 0xe2, 0x59, 0x36, 0x4c, 0xa1,
		0x4e, 0xc9, 0xd8, 0x59, 0x0b, 0xaa, 0x1d, 0xb6, 0x93, 0xe4, 0x68, 0x67, 0xe9, 0x9b, 0xdb, 0x2b,
		0x5c, 0xf7, 0xc7, 0x70, 0xda, 0x91, 0x79, 0x40, 0x44, 0x88, 0x40, 0xd1, 0x8a, 0xb1, 0x74, 0x34,
		0x4f, 0x09, 0x16, 0xeb, 0xfb, 0x81, 0x95, 0xba, 0x04, 0x48, 0xde, 0x6a, 0x00, 0xe9, 0x81, 0x21,
		0x71, 0x69, 0x7a, 0xf1, 0xbf, 0xdb, 0xa8, 0xe0, 0x16, 0x48, 0x3b, 0x7d, 0xa5, 0x9d, 0xe8, 0xfd,
		0x46, 0xca, 0xce, 0x01, 0x2b, 0xd4, 0x17, 0x8b, 0x55, 0xb6, 0x96, 0xcb, 0x6b, 0xd1, 0xc4, 0xa2,
		0x6e, 0x9e, 0x01, 0xdd, 0xc5, 0xa8, 0x78, 0xc2, 0xa2, 0xef, 0x7e, 0x5c, 0xf1, 0x07, 0x06, 0xdd,
		0x76, 0xaf, 0x1d, 0x79, 0xcc, 0xdd, 0x78, 0x8f, 0x10, 0x38, 0xe3, 0x09, 0x9f, 0xe1, 0x83, 0x21,
		0x86, 0x67, 0xec, 0xfd, 0x00, 0x9f, 0x96, 0x60, 0xea, 0xd3, 0x1f, 0xa2, 0x6f, 0x6f, 0x87, 0x5b,
		0x83, 0xf1, 0xc1, 0xe6, 0xc2, 0x5d, 0xc5, 0x68, 0x53, 0xc9, 0x18, 0x15, 0x59, 0xed, 0xf1, 0x01,
		0x8a, 0x6f, 0xef, 0x14, 0x87, 0xdf, 0x08, 0xfd, 0x5e, 0xb1, 0x80, 0x21, 0x1c, 0x5b, 0x3f, 0xd8,
		0x98, 0x6c, 0xfa, 0x11, 0x0f, 0xfd, 0xda, 0xde, 0x5c, 0xc3, 0x1a, 0x14, 0xea, 0xee, 0x09, 0x64,
		0xaf, 0xab, 0xe4, 0x32, 0xe7, 0xf4, 0x5b, 0x66, 0x53, 0xfd, 0xe8, 0xcc, 0xa8, 0x24, 0xa3, 0x1b,
		0xc6, 0xed, 0xd8, 0xd1, 0xba, 0xeb, 0x5f, 0x13, 0xd0, 0xde, 0x15, 0x45, 0xc8, 0x89, 0x44, 0xc6,
		0x47, 0x66, 0xa9, 0x9f, 0x0d, 0x5d, 0x36, 0xd3, 0x7c, 0x71, 0xed, 0xd9, 0xd8, 0xe6, 0x6d, 0x70,
		0xbb, 0x4b, 0xce, 0x0d, 0x97, 0xee, 0xb2, 0x1a, 0x53, 0x8e, 0xe5, 0xbd, 0x5a, 0x9e, 0x8c, 0x93,
		0xb2, 0x9b, 0x2b, 0xec, 0x85, 0x0c, 0x3a, 0x1e, 0x7c, 0xac, 0xa4, 0xe0, 0xd7, 0x27, 0x39, 0xa6,
		0x0c, 0xab, 0x94, 0x73, 0x8c, 0xdc, 0xb9, 0x8c, 0x00, 0x0a, 0x43, 0xd6, 0x94, 0xe5, 0xf1, 0x93,
		0x9b, 0x13, 0x89, 0xba, 0x11, 0x63, 0x03, 0x46, 0x84, 0x76, 0xa8, 0xb9, 0x84, 0x61, 0x30, 0x3e,
		0xfe, 0x23, 0x8d, 0xea, 0x44, 0x99, 0x76, 0x29, 0x36, 0x2d, 0x6f, 0x52, 0x1f, 0x42, 0x54, 0x84,
		0x8e, 0x10, 0xc9, 0xd3, 0x89, 0x19, 0x55, 0x76, 0xb1, 0xb9, 0x92, 0x2d, 0x92, 0xd3, 0xa6, 0x61,
		0xe7, 0x37, 0x6e, 0xd1, 0xe7, 0x7c, 0x04, 0xfc, 0x39, 0xc7, 0x4f, 0xd8, 0x14, 0x80, 0xef, 0xb2,
		0x69, 0xaf, 0x12, 0x29, 0x42, 0x64, 0x8f, 0xdc, 0x82, 0x0f, 0xd6, 0xef, 0x25, 0x30, 0x47, 0x1d,
		0x8c, 0xcf, 0x71, 0xf1, 0xb9, 0xf6, 0x87, 0x04, 0x91, 0xbc, 0x56, 0xd1, 0xc1, 0xd4, 0x24, 0x54,
		0x32, 0xe1, 0x0c, 0xb7, 0x4a, 0x32, 0x3f, 0x71, 0xfe, 0xf7, 0xd8, 0x4d, 0xb1, 0xff, 0x00, 0x35,
		0x8a, 0x72, 0xd3, 0x4d, 0x87, 0x6c, 0x9f, 0x63, 0x6b, 0x67, 0x2b, 0x8c, 0xb8, 0x9c, 0x7c, 0x35,
		0xfb, 0x00, 0xac, 0xcf, 0x40, 0xc6, 0x21, 0x82, 0x36, 0x1c, 0x82, 0x90, 0xca, 0x48, 0x08, 0xfb,
		0x7b, 0x0b, 0xdd, 0xbd, 0xc8, 0x25, 0xb3, 0x37, 0xb2, 0x92, 0x99, 0xb0, 0x66, 0xe0, 0xab, 0xe4,
		0x4e, 0x08, 0x02, 0xf4, 0x08, 0x90, 0x3b, 0xc2, 0xca, 0xd2, 0x0f, 0x94, 0xcc, 0x8e, 0x2d, 0x3d,
		0xb5, 0xd1, 0x49, 0x1c, 0xde, 0xd4, 0x51, 0xc0, 0x5e, 0xc4, 0xe4, 0x90, 0x9f, 0xec, 0xd1, 0xf6,
		0x53, 0x9d, 0x8b, 0xeb, 0xb6, 0x0e, 0xe6, 0x26, 0x5b, 0x16, 0x64, 0xe2, 0xed, 0x46, 0xff, 0x5a,
		0xba, 0xc6, 0x3a, 0xf6, 0xcf, 0x08, 0x5f, 0x63, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x6e, 0x6f,
		0x20, 0x61, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x02, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x10, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x20,
		0x20, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00,
		0xd0, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x20, 0x00, 0x02, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x20, 0x00, 0x02, 0x00, 0x00, 0xf0, 0x02, 0x00, 0x00, 0x08, 0x00, 0x00, 0x20,
		0x20, 0x06, 0x00, 0x00, 0xf0, 0x04, 0x00, 0x00, 0x46, 0x6a, 0x3a, 0x9a, 0xc3, 0x06, 0x1d, 0xae,
		0xe5, 0x71, 0xf9, 0xaa, 0x95, 0x8b, 0x2d, 0x4b, 0xc4, 0xfb, 0xec, 0x7c, 0x96, 0xd4, 0xb5, 0x26,
		0x1f, 0xf4, 0x6a, 0xb5, 0xb1, 0x41, 0x80, 0xb6, 0x80, 0x81, 0xb0, 0xb1, 0x76, 0xdc, 0x0b, 0x8c,
		0xa3, 0x4d, 0xe8, 0x3b, 0xbf, 0x10, 0xf4, 0xb4, 0x1a, 0xd8, 0xdf, 0xdf, 0x76, 0xd7, 0x4a, 0xf7,
		0xbd, 0x9c, 0x5a, 0xe7, 0xde, 0x71, 0xfc, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd7, 0xcd, 0xd5, 0x18, 0x56, 0x19, 0x3e, 0x95,
		0xa3, 0xf2, 0xe5, 0x17, 0x8e, 0x05, 0x40, 0x52, 0x85, 0xf9, 0x9b, 0x5c, 0x6b, 0x45, 0xdf, 0x48,
		0xb6, 0x91, 0xcf, 0x27, 0x98, 0xfa, 0x97, 0x6f, 0x92, 0x20, 0x00, 0x27, 0x23, 0xb4, 0x92, 0x21,
		0x8a, 0xc0, 0xf5, 0xc7, 0x6d, 0x80, 0x47, 0x88, 0x86, 0x44, 0x13, 0x3c, 0x89, 0xec, 0x8c, 0x53,
		0x69, 0xeb, 0xea, 0xbc, 0x35, 0xfb, 0x7b, 0x3c, 0x79, 0x1c, 0xcd, 0x80, 0x75, 0xf0, 0xf1, 0x5b,
		0x0d, 0xb1, 0x3a, 0xd1, 0xf0, 0xc2, 0x62, 0xdc, 0x09, 0x75, 0xb3, 0xb2, 0xc8, 0x3a, 0x2b, 0x5a,
		0x78, 0xe9, 0x08, 0xdd, 0x4c, 0x01, 0xc7, 0xf0, 0xbc, 0x12, 0x34, 0xbf, 0x71, 0x13, 0x23, 0x5c,
		0x2b, 0x99, 0x3d, 0x58, 0xfc, 0x86, 0x7e, 0xe8, 0x6b, 0x66, 0xe6, 0xb3, 0x01, 0xbd, 0xaf, 0x92,
		0xe1, 0x3b, 0x39, 0x50, 0xad, 0x7b, 0x6e, 0x8f, 0xab, 0xce, 0x83, 0x7c, 0x3f, 0x55, 0xed, 0x71,
		0xcd, 0x2b, 0x3a, 0xd7, 0x4d, 0xd5, 0x46, 0x6c, 0x0f, 0xdb, 0xdd, 0x1b, 0x2b, 0x67, 0xe2, 0x44,
		0x87, 0xc3, 0x77, 0xe6, 0x88, 0x6d, 0xd6, 0x3e, 0xe7, 0x7c, 0x24, 0x58, 0xa8, 0x8f, 0xc3, 0x12,
		0xa9, 0xd3, 0x5c, 0xfa, 0x7d, 0x79, 0xde, 0xa7, 0xb9, 0xcc, 0x3b, 0x22, 0xa7, 0xe9, 0xf5, 0x6a,
		0x51, 0x7b, 0xad, 0x32, 0x86, 0x4f, 0x6a, 0x05, 0x30, 0x04, 0x74, 0x9d, 0xd5, 0x48, 0x92, 0x4d,
		0x49, 0xf3, 0x78, 0x8e, 0x04, 0x4c, 0x54, 0x59, 0xfb, 0x0f, 0x61, 0x9e, 0x1a, 0xc4, 0x3d, 0x01,
		0x4e, 0x82, 0x8b, 0x82, 0x0c, 0x8c, 0xf1, 0xe5, 0xc2, 0x14, 0x4f, 0xb9, 0xf7, 0x1c, 0xee, 0x9e,
		0x49, 0x53, 0xd3, 0x34, 0xb1, 0x69, 0x91, 0x68, 0x10, 0x47, 0xda, 0x09, 0x30, 0xdb, 0x90, 0xf1,
		0xd5, 0x51, 0xa2, 0x89, 0x87, 0xb9, 0x9d, 0xc8, 0xf4, 0x9b, 0xec, 0xb6, 0x79, 0xdc, 0x07, 0x02,
		0xaf, 0x78, 0xf5, 0xbe, 0x9e, 0x35, 0x20, 0xdc, 0x91, 0xd2, 0x6c, 0xef, 0xcb, 0x8c, 0xce, 0xd7,
		0x78, 0xc0, 0x76, 0x44, 0x30, 0x90, 0x49, 0x44, 0x66, 0x11, 0xa0, 0xb3, 0x54, 0x18, 0x70, 0x5a,
		0x19, 0xda, 0x5d, 0x50, 0x4a, 0x5b, 0xb1, 0xa6, 0xb0, 0x7f, 0x38, 0x1a, 0x99, 0xbd, 0x25, 0xa0,
		0xc1, 0x92, 0x15, 0x5e, 0x75, 0x34, 0x8f, 0x7d, 0x29, 0x1f, 0x0d, 0xb8, 0x87, 0xb1, 0x9c, 0x5c,
		0x83, 0x55, 0xa1, 0x38, 0xde, 0xd5, 0x81, 0x5a, 0xc4, 0x4e, 0x3a, 0xfe, 0x2c, 0xae, 0x30, 0xd3,
		0x54, 0xb5, 0x35, 0xe8, 0xdd, 0x6d, 0x97, 0x3e, 0x88, 0x62, 0xb6, 0x79, 0xbf, 0x4d, 0xfb, 0xc5,
		0x64, 0x2b, 0xb7, 0x06, 0xc4, 0x71, 0xb3, 0x6f, 0xa4, 0xae, 0x39, 0x56, 0xd7, 0x17, 0x20, 0xde,
		0x7e, 0x45, 0xff, 0x6c, 0x4c, 0x0f, 0xb1, 0x78, 0x57, 0x57, 0x95, 0x4c, 0x9f, 0x6e, 0x1c, 0x14,
		0x68, 0x30, 0x40, 0x55, 0x4b, 0x80, 0x37, 0xa6, 0x2a, 0xd4, 0x51, 0x9d, 0x95, 0x24, 0x6a, 0xda,
		0x88, 0xba, 0xbd, 0x42, 0x9a, 0x47, 0x48, 0xa6, 0x76, 0x2a, 0x24, 0xfc, 0xe9, 0x4b, 0x7c, 0xd9,
		0x3f, 0xdf, 0x29, 0xbe, 0xaa, 0x1a, 0xa9, 0xa8, 0xe8, 0x21, 0xa7, 0x27, 0x07, 0x05, 0x1d, 0x76,
		0x24, 0x3a, 0x7f, 0x5d, 0x98, 0xc8, 0x18, 0x51, 0x12, 0xaf, 0xbf, 0xd1, 0xf5, 0x2b, 0x7f, 0xcb,
		0xfe, 0x3c, 0x79, 0xa6, 0x69, 0x0f, 0xb4, 0xe6, 0x6a, 0x32, 0xc9, 0x2b, 0x1e, 0x6b, 0xce, 0x71,
		0x84, 0x87, 0x37, 0x0e, 0x83, 0x08, 0x8f, 0x1d, 0x6e, 0x28, 0xa3, 0x4e, 0x5b, 0xb6, 0x2b, 0xfe,
		0x6c, 0xbb, 0xf0, 0x21, 0xce, 0x81, 0xd8, 0x2c, 0x9c, 0x39, 0x32, 0x67, 0x08, 0xa7, 0x8c, 0x03,
		0x67, 0x62, 0x88, 0x66, 0xd6, 0x3c, 0x66, 0xcf, 0x28, 0xab, 0x82, 0x74, 0xd0, 0xfb, 0xfa, 0x9f,
		0xd3, 0x05, 0x5f, 0xf5, 0xa2, 0x36, 0x1c, 0x34, 0xe1, 0x98, 0xb0, 0xfb, 0xb5, 0xc8, 0x3f, 0xb1,
		0xb9, 0x96, 0x0a, 0xd3, 0xe4, 0xe7, 0xa8, 0xfd, 0x14, 0x84, 0x32, 0x3d, 0x8c, 0x05, 0xa7, 0x9d,
		0xa6, 0xcb, 0x59, 0x7d, 0x47, 0x61, 0xca, 0x05, 0xd7, 0xdb, 0x20, 0x78, 0xaf, 0xa3, 0x10, 0xb0,
		0xd9, 0x4c, 0xe7, 0x28, 0xa0, 0x10, 0x1f, 0xb8, 0x0e, 0x0e, 0x49, 0x2c, 0xde, 0x64, 0x0e, 0x64,
		0x78, 0x7d, 0x70, 0x31, 0x77, 0x74, 0x9a, 0x39, 0x26, 0xcc, 0x20, 0x0e, 0x88, 0xc8, 0x23, 0xb6,
		0xba, 0xe2, 0x73, 0x77, 0x43, 0xb0, 0xca, 0x8a, 0xb7, 0x17, 0xbe, 0x55, 0x4a, 0xe4, 0x93, 0x38,
		0x06, 0xf8, 0x62, 0x44, 0x43, 0x46, 0xd5, 0x3e, 0x80, 0xb6, 0xf5, 0x4b, 0x69, 0x98, 0x5b, 0x9f,
		0xbe, 0xe9, 0xf0, 0xea, 0xf2, 0x42, 0x0c, 0xf4, 0xe6, 0x28, 0x25, 0x51, 0x6e, 0xa3, 0x53, 0xcc,
		0xbd, 0xec, 0x85, 0x61, 0x7e, 0x4a, 0xab, 0x1c, 0xb4, 0x8e, 0x82, 0x55, 0x97, 0x38, 0xc1, 0xa4,
		0x91, 0x72, 0x5d, 0x69, 0x4c, 0x84, 0x7d, 0xa1, 0x4c, 0xf7, 0x3b, 0x76, 0xce, 0x78, 0x00, 0x10,
		0xaa, 0xbd, 0xa4, 0x2e, 0xc7, 0xb2, 0x41, 0x71, 0xd0, 0xa7, 0xfd, 0x7f, 0x38, 0x5b, 0x4f, 0x86,
		0x9f, 0x8f, 0x6f, 0x20, 0x25, 0x37, 0xe1, 0xb7, 0xc4, 0xe2, 0x64, 0x60, 0x4e, 0x66, 0x2d, 0xec,
		0x93, 0x7b, 0xd9, 0xa8, 0xe8, 0xd8, 0x33, 0xb2, 0x9c, 0x29, 0xe4, 0x9d, 0x2e, 0xe7, 0x32, 0xdd,
		0x2b, 0x85, 0x5d, 0x41, 0x40, 0xd8, 0xe7, 0xb6, 0xa6, 0xe8, 0xfa, 0xe7, 0x16, 0x45, 0x12, 0xe7,
		0xbd, 0x89, 0x47, 0xde, 0xfb, 0x17, 0x0d, 0xa6, 0x48, 0x9f, 0xf3, 0x3e, 0x24, 0x4d, 0xdc, 0xe2,
		0xbf, 0xcf, 0x5d, 0xc7, 0x2e, 0xfa, 0xd6, 0x4c, 0x16, 0x59, 0x52, 0x48, 0xb8, 0x2c, 0x79, 0xe2,
		0xa4, 0x8c, 0x79, 0x08, 0x4e, 0xfc, 0xe3, 0x38, 0x75, 0x70, 0x2e, 0x1a, 0xbe, 0x38, 0x0b, 0x3f,
		0x9f, 0xd7, 0x77, 0x99, 0x95, 0x3a, 0xd7, 0xc1, 0x26, 0x6c, 0x6d, 0x3b, 0x03, 0x8a, 0xcf, 0x8b,
		0x27, 0x2c, 0xf1, 0x14, 0x2f, 0xcc, 0xc6, 0x6f, 0xe9, 0xb0, 0x8f, 0x83, 0xd4, 0x8a, 0x9e, 0xa0,
		0xbb, 0x55, 0x47, 0xc2, 0xe0, 0xe6, 0xfc, 0x10, 0x96, 0x70, 0x94, 0xac, 0x6b, 0xd5, 0xbf, 0xef,
		0xdc, 0x55, 0x2e, 0x93, 0xbd, 0x83, 0xe1, 0xb8, 0x5a, 0x1b, 0xbd, 0x6b, 0xf6, 0xdd, 0xce, 0xf4,
		0xb2, 0x06, 0x69, 0xd7, 0x58, 0x68, 0x9f, 0x10, 0x2d, 0xa4, 0x77, 0x50, 0xe4, 0x24, 0xa9, 0xba,
		0x3c, 0xa2, 0xe3, 0xa1, 0x99, 0x25, 0xe0, 0x46, 0xe5, 0xc7, 0xaa, 0x9a, 0x6a, 0xa2, 0x35, 0x7f,
		0xc5, 0x84, 0xd7, 0x8f, 0x52, 0x8f, 0x39, 0x0f, 0x08, 0xc6, 0xdb, 0x41, 0xd2, 0xc0, 0x24, 0x4f,
		0xd8, 0x40, 0x4e, 0xb1, 0x34, 0x14, 0x21, 0x86, 0xec, 0xb0, 0xd0, 0x1d, 0xf5, 0xac, 0xde, 0xdb,
		0xa3, 0x8f, 0x1e, 0x5a, 0x80, 0xdb, 0x0b, 0x3e, 0x1f, 0xd9, 0xaf, 0x52, 0x7f, 0x91, 0x55, 0x20,
		0x7b, 0xee, 0xb4, 0x9d, 0x70, 0xa9, 0x88, 0x83, 0x22, 0xc7, 0x49, 0x3f, 0x0a, 0xb7, 0xb2, 0xbd,
		0x85, 0xb0, 0x05, 0x7a, 0x11, 0x19, 0xad, 0x57, 0x36, 0xf1, 0xc0, 0x49, 0xea, 0xe5, 0x21, 0x01,
		0x34, 0x0a, 0x94, 0x76, 0xdb, 0x34, 0xf7, 0x10, 0x15, 0x7b, 0xb0, 0x70, 0x39, 0xaf, 0x7d, 0x71,
		0x48, 0x09, 0x88, 0xc0, 0x94, 0xd0, 0xf6, 0xc2, 0xf0, 0xe2, 0xf5, 0xe4, 0x2e, 0xd2, 0x5a, 0x2c,
		0xd9, 0x42, 0x58, 0xf3, 0x5d, 0x85, 0x90, 0x1f, 0x3a, 0x43, 0x7c, 0x58, 0xf6, 0x35, 0x35, 0x1f,
		0x68, 0x1c, 0x0a, 0xd6, 0x6a, 0x8f, 0x8b, 0x64, 0x4d, 0x49, 0x49, 0x45, 0x6b, 0x6a, 0x43, 0x43,
		0x41, 0x33, 0x71, 0x67, 0x41, 0x77, 0x49, 0x42, 0x41, 0x67, 0x49, 0x52, 0x45, 0x56, 0x4f, 0x47,
		0x74, 0x4c, 0x6a, 0x7a, 0x57, 0x4c, 0x2b, 0x39, 0x36, 0x58, 0x4a, 0x46, 0x79, 0x69, 0x58, 0x49,
		0x51, 0x30, 0x38, 0x77, 0x44, 0x51, 0x59, 0x4a, 0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e,
		0x41, 0x51, 0x45, 0x4c, 0x42, 0x51, 0x41, 0x77, 0x50, 0x54, 0x45, 0x4c, 0x4d, 0x41, 0x6b, 0x47,
		0x41, 0x31, 0x55, 0x45, 0x42, 0x68, 0x4d, 0x43, 0x51, 0x30, 0x34, 0x78, 0x44, 0x7a, 0x41, 0x4e,
		0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x6f, 0x54, 0x42, 0x6b, 0x68, 0x31, 0x59, 0x58, 0x64, 0x6c,
		0x61, 0x54, 0x45, 0x64, 0x4d, 0x42, 0x73, 0x47, 0x41, 0x31, 0x55, 0x45, 0x41, 0x78, 0x4d, 0x55,
		0x53, 0x48, 0x56, 0x68, 0x64, 0x32, 0x56, 0x70, 0x49, 0x45, 0x6c, 0x55, 0x49, 0x46, 0x42, 0x79,
		0x62, 0x32, 0x52, 0x31, 0x59, 0x33, 0x51, 0x67, 0x51, 0x30, 0x45, 0x77, 0x48, 0x68, 0x63, 0x4e,
		0x4d, 0x6a, 0x49, 0x77, 0x4e, 0x44, 0x45, 0x78, 0x4d, 0x44, 0x59, 0x7a, 0x4e, 0x54, 0x41, 0x79,
		0x57, 0x68, 0x63, 0x4e, 0x4d, 0x7a, 0x63, 0x77, 0x4e, 0x44, 0x41, 0x33, 0x4d, 0x44, 0x59, 0x7a,
		0x4e, 0x54, 0x41, 0x79, 0x57, 0x6a, 0x41, 0x36, 0x4d, 0x51, 0x73, 0x77, 0x43, 0x51, 0x59, 0x44,
		0x56, 0x51, 0x51, 0x47, 0x45, 0x77, 0x4a, 0x44, 0x54, 0x6a, 0x45, 0x50, 0x4d, 0x41, 0x30, 0x47,
		0x41, 0x31, 0x55, 0x45, 0x43, 0x68, 0x4d, 0x47, 0x53, 0x48, 0x56, 0x68, 0x64, 0x32, 0x56, 0x70,
		0x4d, 0x52, 0x6f, 0x77, 0x47, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51, 0x44, 0x45, 0x78, 0x45, 0x77,
		0x4d, 0x6a, 0x5a, 0x51, 0x55, 0x46, 0x59, 0x78, 0x4d, 0x45, 0x74, 0x44, 0x4d, 0x44, 0x41, 0x30,
		0x4d, 0x54, 0x63, 0x35, 0x56, 0x44, 0x43, 0x43, 0x41, 0x69, 0x49, 0x77, 0x44, 0x51, 0x59, 0x4a,
		0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45, 0x42, 0x42, 0x51, 0x41, 0x44,
		0x67, 0x67, 0x49, 0x50, 0x41, 0x44, 0x43, 0x43, 0x41, 0x67, 0x6f, 0x43, 0x67, 0x67, 0x49, 0x42,
		0x41, 0x4e, 0x6e, 0x38, 0x62, 0x7a, 0x49, 0x72, 0x67, 0x78, 0x61, 0x41, 0x34, 0x58, 0x7a, 0x46,
		0x46, 0x58, 0x4b, 0x38, 0x59, 0x61, 0x48, 0x4e, 0x55, 0x4e, 0x48, 0x67, 0x68, 0x68, 0x47, 0x32,
		0x59, 0x78, 0x48, 0x38, 0x66, 0x77, 0x38, 0x6b, 0x49, 0x53, 0x2f, 0x50, 0x5a, 0x63, 0x73, 0x64,
		0x65, 0x7a, 0x36, 0x59, 0x35, 0x4b, 0x67, 0x70, 0x4d, 0x54, 0x32, 0x74, 0x65, 0x34, 0x64, 0x56,
		0x4a, 0x58, 0x6b, 0x61, 0x43, 0x78, 0x55, 0x65, 0x77, 0x52, 0x31, 0x66, 0x6d, 0x55, 0x6f, 0x50,
		0x30, 0x65, 0x2b, 0x6c, 0x69, 0x6b, 0x58, 0x79, 0x59, 0x5a, 0x66, 0x6d, 0x71, 0x78, 0x31, 0x7a,
		0x49, 0x56, 0x68, 0x6b, 0x34, 0x6d, 0x33, 0x6b, 0x6e, 0x2b, 0x49, 0x58, 0x37, 0x78, 0x39, 0x73,
		0x74, 0x4c, 0x7a, 0x2b, 0x6f, 0x47, 0x43, 0x5a, 0x61, 0x78, 0x36, 0x31, 0x73, 0x2b, 0x75, 0x44,
		0x61, 0x36, 0x70, 0x48, 0x4c, 0x63, 0x78, 0x54, 0x35, 0x4a, 0x59, 0x46, 0x59, 0x68, 0x55, 0x47,
		0x67, 0x61, 0x65, 0x6c, 0x4d, 0x70, 0x4b, 0x69, 0x71, 0x6a, 0x61, 0x2f, 0x48, 0x5a, 0x36, 0x68,
		0x74, 0x42, 0x51, 0x6d, 0x68, 0x67, 0x56, 0x2f, 0x34, 0x51, 0x71, 0x4c, 0x79, 0x74, 0x7a, 0x59,
		0x4a, 0x4a, 0x57, 0x36, 0x65, 0x51, 0x68, 0x46, 0x73, 0x2b, 0x41, 0x6f, 0x54, 0x45, 0x4c, 0x79,
		0x46, 0x61, 0x41, 0x6b, 0x42, 0x57, 0x52, 0x59, 0x33, 0x69, 0x51, 0x51, 0x6c, 0x4e, 0x79, 0x36,
		0x68, 0x6c, 0x57, 0x6c, 0x46, 0x6b, 0x4c, 0x54, 0x42, 0x47, 0x58, 0x49, 0x66, 0x2f, 0x67, 0x41,
		0x36, 0x32, 0x68, 0x32, 0x78, 0x4e, 0x70, 0x77, 0x70, 0x4f, 0x56, 0x47, 0x63, 0x46, 0x2f, 0x66,
		0x2f, 0x66, 0x6b, 0x75, 0x30, 0x65, 0x47, 0x72, 0x55, 0x64, 0x75, 0x59, 0x50, 0x6d, 0x38, 0x61,
		0x54, 0x65, 0x36, 0x73, 0x48, 0x4f, 0x36, 0x48, 0x39, 0x57, 0x61, 0x63, 0x4c, 0x70, 0x53, 0x6f,
		0x30, 0x77, 0x53, 0x6a, 0x73, 0x68, 0x68, 0x30, 0x4f, 0x31, 0x53, 0x37, 0x6b, 0x71, 0x65, 0x49,
		0x51, 0x31, 0x4b, 0x75, 0x68, 0x43, 0x63, 0x49, 0x64, 0x42, 0x72, 0x4a, 0x45, 0x63, 0x72, 0x6a,
		0x50, 0x39, 0x44, 0x55, 0x33, 0x42, 0x72, 0x70, 0x78, 0x6c, 0x73, 0x72, 0x4e, 0x49, 0x2b, 0x2b,
		0x47, 0x79, 0x35, 0x74, 0x6b, 0x2b, 0x39, 0x43, 0x74, 0x59, 0x4f, 0x35, 0x6c, 0x4e, 0x4b, 0x55,
		0x6d, 0x32, 0x47, 0x51, 0x5a, 0x43, 0x52, 0x56, 0x4a, 0x68, 0x31, 0x71, 0x51, 0x63, 0x57, 0x6f,
		0x78, 0x50, 0x59, 0x36, 0x54, 0x62, 0x43, 0x49, 0x65, 0x36, 0x62, 0x32, 0x2f, 0x68, 0x68, 0x52,
		0x46, 0x74, 0x75, 0x49, 0x33, 0x65, 0x58, 0x70, 0x67, 0x33, 0x2f, 0x39, 0x66, 0x59, 0x6d, 0x4d,
		0x62, 0x59, 0x4a, 0x6f, 0x76, 0x53, 0x6f, 0x57, 0x71, 0x7a, 0x41, 0x2b, 0x53, 0x36, 0x42, 0x2f,
		0x4f, 0x76, 0x76, 0x67, 0x42, 0x56, 0x31, 0x61, 0x37, 0x33, 0x68, 0x77, 0x69, 0x2f, 0x42, 0x57,
		0x62, 0x5a, 0x38, 0x39, 0x6d, 0x63, 0x37, 0x58, 0x6e, 0x76, 0x4b, 0x72, 0x35, 0x31, 0x50, 0x45,
		0x79, 0x42, 0x2b, 0x4e, 0x73, 0x2b, 0x45, 0x4a, 0x71, 0x73, 0x35, 0x57, 0x59, 0x33, 0x67, 0x57,
		0x2f, 0x77, 0x55, 0x69, 0x66, 0x6a, 0x38, 0x77, 0x55, 0x65, 0x52, 0x4b, 0x65, 0x6a, 0x57, 0x78,
		0x67, 0x43, 0x35, 0x70, 0x4a, 0x42, 0x55, 0x47, 0x39, 0x4f, 0x59, 0x63, 0x72, 0x73, 0x62, 0x59,
		0x68, 0x4c, 0x73, 0x74, 0x50, 0x32, 0x70, 0x77, 0x6f, 0x48, 0x71, 0x5a, 0x2b, 0x64, 0x45, 0x6b,
		0x59, 0x31, 0x6f, 0x2b, 0x4f, 0x63, 0x68, 0x6f, 0x5a, 0x6e, 0x57, 0x61, 0x59, 0x79, 0x64, 0x77,
		0x58, 0x64, 0x38, 0x30, 0x41, 0x63, 0x62, 0x35, 0x63, 0x64, 0x39, 0x4d, 0x51, 0x31, 0x48, 0x32,
		0x73, 0x56, 0x64, 0x31, 0x4c, 0x54, 0x6f, 0x70, 0x57, 0x30, 0x4b, 0x76, 0x48, 0x68, 0x47, 0x51,
		0x51, 0x35, 0x38, 0x4d, 0x6b, 0x4d, 0x51, 0x55, 0x49, 0x67, 0x4f, 0x46, 0x35, 0x57, 0x6a, 0x6d,
		0x69, 0x58, 0x4c, 0x55, 0x73, 0x43, 0x61, 0x70, 0x44, 0x77, 0x6c, 0x76, 0x6b, 0x44, 0x47, 0x70,
		0x73, 0x6f, 0x36, 0x50, 0x61, 0x69, 0x37, 0x75, 0x51, 0x4e, 0x66, 0x45, 0x39, 0x2f, 0x79, 0x4e,
		0x36, 0x51, 0x5a, 0x58, 0x38, 0x55, 0x71, 0x6c, 0x70, 0x4e, 0x68, 0x35, 0x30, 0x2f, 0x57, 0x37,
		0x2b, 0x2b, 0x46, 0x6b, 0x35, 0x4b, 0x4a, 0x59, 0x61, 0x37, 0x6f, 0x59, 0x43, 0x53, 0x64, 0x38,
		0x66, 0x4f, 0x6d, 0x54, 0x49, 0x47, 0x4c, 0x5a, 0x6e, 0x51, 0x64, 0x71, 0x35, 0x41, 0x53, 0x5a,
		0x56, 0x56, 0x33, 0x47, 0x78, 0x63, 0x64, 0x71, 0x50, 0x35, 0x46, 0x72, 0x67, 0x70, 0x55, 0x52,
		0x33, 0x51, 0x42, 0x2f, 0x4f, 0x77, 0x54, 0x37, 0x37, 0x56, 0x66, 0x38, 0x4c, 0x36, 0x52, 0x41,
		0x6e, 0x38, 0x34, 0x69, 0x4f, 0x44, 0x73, 0x66, 0x50, 0x44, 0x42, 0x7a, 0x41, 0x67, 0x4d, 0x42,
		0x41, 0x41, 0x47, 0x6a, 0x67, 0x59, 0x38, 0x77, 0x67, 0x59, 0x77, 0x77, 0x48, 0x77, 0x59, 0x44,
		0x56, 0x52, 0x30, 0x6a, 0x42, 0x42, 0x67, 0x77, 0x46, 0x6f, 0x41, 0x55, 0x45, 0x6f, 0x6f, 0x33,
		0x37, 0x50, 0x6c, 0x7a, 0x56, 0x39, 0x66, 0x6b, 0x67, 0x37, 0x71, 0x31, 0x62, 0x77, 0x50, 0x73,
		0x33, 0x61, 0x34, 0x52, 0x54, 0x73, 0x38, 0x77, 0x43, 0x77, 0x59, 0x44, 0x56, 0x52, 0x30, 0x50,
		0x42, 0x41, 0x51, 0x44, 0x41, 0x67, 0x50, 0x34, 0x4d, 0x46, 0x77, 0x47, 0x43, 0x43, 0x73, 0x47,
		0x41, 0x51, 0x55, 0x46, 0x42, 0x77, 0x45, 0x42, 0x42, 0x46, 0x41, 0x77, 0x54, 0x6a, 0x41, 0x6f,
		0x42, 0x67, 0x67, 0x72, 0x42, 0x67, 0x45, 0x46, 0x42, 0x51, 0x63, 0x77, 0x41, 0x6f, 0x59, 0x63,
		0x61, 0x48, 0x52, 0x30, 0x63, 0x44, 0x6f, 0x76, 0x4c, 0x7a, 0x45, 0x79, 0x4e, 0x79, 0x34, 0x77,
		0x4c, 0x6a, 0x41, 0x75, 0x4d, 0x53, 0x39, 0x6a, 0x59, 0x57, 0x6c, 0x7a, 0x63, 0x33, 0x56, 0x6c,
		0x4c, 0x6d, 0x68, 0x30, 0x62, 0x54, 0x41, 0x69, 0x42, 0x67, 0x67, 0x72, 0x42, 0x67, 0x45, 0x46,
		0x42, 0x51, 0x63, 0x77, 0x41, 0x59, 0x59, 0x57, 0x61, 0x48, 0x52, 0x30, 0x63, 0x44, 0x6f, 0x76,
		0x4c, 0x7a, 0x45, 0x79, 0x4e, 0x79, 0x34, 0x77, 0x4c, 0x6a, 0x41, 0x75, 0x4d, 0x54, 0x6f, 0x79,
		0x4d, 0x44, 0x51, 0x30, 0x4d, 0x7a, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47,
		0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x73, 0x46, 0x41, 0x41, 0x4f, 0x43, 0x41, 0x51, 0x45, 0x41,
		0x48, 0x57, 0x35, 0x39, 0x66, 0x6d, 0x4c, 0x63, 0x55, 0x32, 0x64, 0x2b, 0x69, 0x63, 0x6e, 0x63,
		0x61, 0x47, 0x58, 0x65, 0x68, 0x53, 0x72, 0x65, 0x48, 0x45, 0x63, 0x51, 0x38, 0x55, 0x6d, 0x64,
		0x58, 0x58, 0x31, 0x35, 0x6b, 0x71, 0x37, 0x79, 0x2b, 0x67, 0x59, 0x33, 0x49, 0x66, 0x49, 0x69,
		0x4d, 0x48, 0x31, 0x49, 0x43, 0x4d, 0x54, 0x56, 0x4b, 0x2f, 0x58, 0x44, 0x6c, 0x56, 0x59, 0x47,
		0x79, 0x6d, 0x31, 0x71, 0x6f, 0x51, 0x77, 0x62, 0x57, 0x78, 0x4f, 0x4a, 0x2f, 0x46, 0x38, 0x41,
		0x67, 0x38, 0x41, 0x59, 0x56, 0x4d, 0x58, 0x71, 0x5a, 0x47, 0x65, 0x6b, 0x51, 0x45, 0x38, 0x42,
		0x64, 0x66, 0x4d, 0x4e, 0x4d, 0x6d, 0x42, 0x67, 0x67, 0x39, 0x68, 0x7a, 0x47, 0x75, 0x68, 0x58,
		0x49, 0x76, 0x2b, 0x6c, 0x73, 0x37, 0x78, 0x39, 0x75, 0x52, 0x41, 0x6c, 0x4a, 0x44, 0x56, 0x56,
		0x32, 0x35, 0x6b, 0x4e, 0x39, 0x61, 0x4d, 0x58, 0x2f, 0x36, 0x45, 0x50, 0x59, 0x36, 0x69, 0x39,
		0x71, 0x48, 0x31, 0x4f, 0x39, 0x4a, 0x77, 0x37, 0x51, 0x45, 0x67, 0x77, 0x4f, 0x62, 0x65, 0x4c,
		0x4e, 0x45, 0x33, 0x55, 0x5a, 0x63, 0x6e, 0x39, 0x6c, 0x4f, 0x74, 0x43, 0x50, 0x57, 0x64, 0x58,
		0x67, 0x58, 0x43, 0x51, 0x39, 0x39, 0x67, 0x36, 0x6d, 0x62, 0x49, 0x30, 0x37, 0x4a, 0x78, 0x37,
		0x66, 0x59, 0x34, 0x51, 0x2b, 0x73, 0x55, 0x4a, 0x4e, 0x42, 0x4c, 0x6a, 0x34, 0x35, 0x62, 0x73,
		0x2f, 0x49, 0x49, 0x43, 0x63, 0x50, 0x6a, 0x41, 0x51, 0x2f, 0x47, 0x62, 0x37, 0x7a, 0x34, 0x48,
		0x52, 0x70, 0x4b, 0x43, 0x44, 0x42, 0x33, 0x53, 0x74, 0x7a, 0x36, 0x66, 0x5a, 0x33, 0x48, 0x63,
		0x52, 0x56, 0x62, 0x57, 0x2f, 0x41, 0x32, 0x63, 0x77, 0x31, 0x48, 0x77, 0x50, 0x32, 0x37, 0x6d,
		0x70, 0x6e, 0x59, 0x71, 0x38, 0x6f, 0x6f, 0x74, 0x77, 0x6d, 0x7a, 0x4b, 0x59, 0x72, 0x74, 0x5a,
		0x73, 0x6c, 0x2b, 0x38, 0x62, 0x38, 0x58, 0x42, 0x71, 0x6f, 0x30, 0x4d, 0x73, 0x6d, 0x69, 0x58,
		0x36, 0x6a, 0x47, 0x71, 0x31, 0x49, 0x4a, 0x2f, 0x61, 0x76, 0x33, 0x43, 0x71, 0x43, 0x31, 0x37,
		0x45, 0x46, 0x2b, 0x63, 0x70, 0x53, 0x74, 0x6b, 0x6d, 0x76, 0x5a, 0x71, 0x61, 0x65, 0x64, 0x67,
		0x5a, 0x56, 0x77, 0x4f, 0x73, 0x53, 0x36, 0x64, 0x6f, 0x37, 0x31, 0x78, 0x78, 0x2b, 0x42, 0x67,
		0x50, 0x56, 0x65, 0x32, 0x7a, 0x67, 0x3d, 0x3d}
)

type (
	tpm struct {
		config *TPMConfig
		useHW  bool
		dev    io.ReadWriteCloser
		ek     endorsementKey
		ik     attestationKey
	}

	TPMConfig struct {
		IMALogPath    string
		BIOSLogPath   string
		ReportHashAlg string
		SeedPath      string
	}

	endorsementKey struct {
		pub      crypto.PublicKey
		handle   tpmutil.Handle
		alg      string
		password string
	}

	attestationKey struct {
		pub      crypto.PublicKey
		handle   tpmutil.Handle
		alg      string
		password string
		name     []byte
	}

	IKCertInput struct {
		// CredBlob & EncryptedSecret are created by MakeCredential, and will be given as input to ActivateCredential
		CredBlob        []byte // the protected key used to encrypt IK Cert
		EncryptedSecret []byte // the pretected secret related to protection of CredBlob
		// EncryptedCert is the encrypted IK Cert,
		// will be decypted with the key recovered from CredBlob & EncryptedSecret,
		// decrypted Cert will be in PEM format
		EncryptedCert []byte
		// if DecryptAlg == "AES128-CBC"
		// then it is the IV used to decrypt IK Cert together with the key recovered from CredBlob & EncryptedSecret
		DecryptAlg   string // the algorithm & scheme used to decrypt the IK Cert
		DecryptParam []byte // the parameter required by the decrypt algorithm to decrypt the IK Cert
	}

	TaReportInput struct {
		Uuid     string
		UserData []byte
		WithTcb  bool
	}
)

var (
	ErrWrongParams         = errors.New("wrong input parameter")
	ErrFailTPMInit         = errors.New("couldn't start tpm or init key/certificate")
	ErrReadPCRFail         = errors.New("failed to read all PCRs")
	ErrNotSupportedHashAlg = errors.New("the set hash algorithm  is not supported")

	algStrMap = map[tpm2.Algorithm]string{
		tpm2.AlgSHA1:   "SHA1",
		tpm2.AlgSHA256: "SHA256",
		tpm2.AlgSHA384: "SHA384",
		tpm2.AlgSHA512: "SHA512",
	}

	algIdMap = map[string]tpm2.Algorithm{
		algSHA1Str:   tpm2.AlgSHA1,
		algSHA256Str: tpm2.AlgSHA256,
		algSHA384Str: tpm2.AlgSHA384,
		algSHA512Str: tpm2.AlgSHA512,
		algSM3Str:    AlgSM3,
	}

	// PCR7 is for SecureBoot.
	pcrSelectionNil  = tpm2.PCRSelection{Hash: tpm2.AlgSHA1, PCRs: []int{}}
	pcrSelection0    = tpm2.PCRSelection{Hash: tpm2.AlgSHA1, PCRs: []int{0}}
	pcrSelection0to7 = tpm2.PCRSelection{Hash: tpm2.AlgSHA1, PCRs: []int{0, 1, 2, 3, 4, 5, 6, 7}}
	pcrSelection7    = tpm2.PCRSelection{Hash: tpm2.AlgSHA1, PCRs: []int{7}}
	pcrSelectionAll  = tpm2.PCRSelection{Hash: tpm2.AlgSHA1,
		PCRs: []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
			12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23}}

	// according to TCG specification, B.3.3  Template L-1: RSA 2048 (Storage)
	// https://trustedcomputinggroup.org/wp-content/uploads/TCG_IWG_EKCredentialProfile_v2p4_r3.pdf
	EKParams = tpm2.Public{
		Type:    tpm2.AlgRSA,
		NameAlg: tpm2.AlgSHA256,
		Attributes: tpm2.FlagFixedTPM | tpm2.FlagFixedParent | tpm2.FlagSensitiveDataOrigin |
			tpm2.FlagAdminWithPolicy | tpm2.FlagDecrypt | tpm2.FlagRestricted,

		AuthPolicy: tpmutil.U16Bytes{0x83, 0x71, 0x97, 0x67, 0x44, 0x84,
			0xB3, 0xF8, 0x1A, 0x90, 0xCC, 0x8D,
			0x46, 0xA5, 0xD7, 0x24, 0xFD, 0x52,
			0xD7, 0x6E, 0x06, 0x52, 0x0B, 0x64,
			0xF2, 0xA1, 0xDA, 0x1B, 0x33, 0x14,
			0x69, 0xAA},
		RSAParameters: &tpm2.RSAParams{
			Symmetric: &tpm2.SymScheme{
				Alg:     tpm2.AlgAES,
				KeyBits: 128,
				Mode:    tpm2.AlgCFB,
			},
			KeyBits:     2048,
			ExponentRaw: 0,
			ModulusRaw: tpmutil.U16Bytes{ //256 zeros
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
		},
	}

	// according to TCG specification, 7.3.4.2 Template H-1: RSA 2048
	// https://trustedcomputinggroup.org/wp-content/uploads/TPM-2p0-Keys-for-Device-Identity-and-Attestation_v1_r12_pub10082021.pdf
	IKParams = tpm2.Public{
		Type:    tpm2.AlgRSA,
		NameAlg: tpm2.AlgSHA256,
		Attributes: tpm2.FlagFixedTPM | tpm2.FlagFixedParent | tpm2.FlagSensitiveDataOrigin |
			tpm2.FlagUserWithAuth | tpm2.FlagSign | tpm2.FlagRestricted,

		RSAParameters: &tpm2.RSAParams{
			Sign: &tpm2.SigScheme{
				Alg:  tpm2.AlgRSASSA,
				Hash: tpm2.AlgSHA256,
			},
			KeyBits:     2048,
			ExponentRaw: 0,
		},
	}

	tpmRef *tpm = nil
)

// GetEKPub returns EK public key
func GetEKPub() crypto.PublicKey {
	if tpmRef == nil {
		return nil
	}
	return tpmRef.ek.pub
}

// GetIKPub returns IK public key
func GetIKPub() crypto.PublicKey {
	if tpmRef == nil {
		return nil
	}
	return tpmRef.ik.pub
}

// GetIKName returns IK name
func GetIKName() []byte {
	if tpmRef == nil {
		return nil
	}
	return tpmRef.ik.name
}

// SetDigestAlg method update the Digest alg used to get pcrs and to do the quote.
func SetDigestAlg(alg string) error {
	if tpmRef == nil {
		return ErrFailTPMInit
	}

	if algID, ok := algIdMap[alg]; ok {
		//pcrSelectionNil.Hash = algID
		pcrSelection0.Hash = algID
		pcrSelection0to7.Hash = algID
		pcrSelection7.Hash = algID
		pcrSelectionAll.Hash = algID
		//EKParams.NameAlg = algID
		//IKParams.NameAlg = algID
		//IKParams.RSAParameters.Sign.Hash = algID
		tpmRef.config.ReportHashAlg = alg
		return nil
	}
	return ErrNotSupportedHashAlg

}

// OpenTPM uses either a physical TPM device(default/useHW=true) or a
// simulator(-t/useHW=false), returns a global TPM object variable.
func OpenTPM(useHW bool, conf *TPMConfig, seed int64) error {
	if tpmRef != nil {
		return nil
	}
	if conf == nil {
		return ErrWrongParams
	}
	tpmRef = &tpm{
		config: conf,
		useHW:  useHW,
		dev:    nil,
	}
	SetDigestAlg(conf.ReportHashAlg)
	var err error
	if useHW {
		err = openTpmChip()
	} else {
		err = openTpmSimulator(seed)
	}
	return err
}

// openTpmChip opens TPM hardware chip and reads EC from NVRAM.
// NOTICE:
//
//	User should use tbprovisioner command tool to write the EC
//
// into TPM NVRAM before running raagent or the TPM chip already
// has EC in NVRAM when it comes from manufactories.
func openTpmChip() error {
	var err error
	tpmRef.dev, err = tpm2.OpenTPM(tpmDevPath1)
	if err != nil {
		tpmRef.dev, err = tpm2.OpenTPM(tpmDevPath2)
	}
	return err
}

// openTpmSimulator opens TPM simulator.
// EK/IK key and certificate should be loaded/generated from files by config.
func openTpmSimulator(seed int64) error {
	// GetWithFixedSeedInsecure behaves like Get() expect that all of the
	// internal hierarchy seeds are derived from the input seed. So every
	// time we reopen the simulator, we can always get the same ek for the
	// same input.
	var err error
	tpmRef.dev, err = simulator.GetWithFixedSeedInsecure(seed)
	return err
}

// CloseTPM closes an open tpm device and flushes tpm resources.
func CloseTPM() {
	if tpmRef == nil {
		return
	}
	if tpmRef.ek.handle != tpmutil.Handle(0) {
		tpm2.FlushContext(tpmRef.dev, tpmRef.ek.handle)
	}
	if tpmRef.ik.handle != tpmutil.Handle(0) {
		tpm2.FlushContext(tpmRef.dev, tpmRef.ik.handle)
	}
	tpmRef.dev.Close()
	tpmRef = nil
}

// DefineNVRAM defines the index space as size length in the NVRAM
func DefineNVRAM(idx uint32, size uint16) error {
	if tpmRef == nil {
		return ErrFailTPMInit
	}
	attr := tpm2.AttrOwnerWrite | tpm2.AttrOwnerRead |
		tpm2.AttrWriteSTClear | tpm2.AttrReadSTClear
	return tpm2.NVDefineSpace(tpmRef.dev, tpm2.HandleOwner, tpmutil.Handle(idx),
		emptyPassword, emptyPassword, nil, attr, size)
}

// UndefineNVRAM frees the index space in the NVRAM
func UndefineNVRAM(idx uint32) error {
	if tpmRef == nil {
		return ErrFailTPMInit
	}
	return tpm2.NVUndefineSpace(tpmRef.dev, emptyPassword, tpm2.HandleOwner,
		tpmutil.Handle(idx))
}

// WriteNVRAM writes the data at index into the NVRAM
func WriteNVRAM(idx uint32, data []byte) error {
	if tpmRef == nil {
		return ErrFailTPMInit
	}
	l := uint16(len(data))
	offset := uint16(0)
	end := uint16(0)
	for l > 0 {
		if l < blockSize {
			end = offset + l
			l = 0
		} else {
			end = offset + blockSize
			l -= blockSize
		}
		err := tpm2.NVWrite(tpmRef.dev, tpm2.HandleOwner, tpmutil.Handle(idx),
			emptyPassword, data[offset:end], offset)
		if err != nil {
			return err
		}
		offset = end
	}
	return nil
}

// ReadNVRAM reads the data at index from the NVRAM
func ReadNVRAM(idx uint32) ([]byte, error) {
	if tpmRef == nil {
		return nil, ErrFailTPMInit
	}
	return tpm2.NVReadEx(tpmRef.dev, tpmutil.Handle(idx),
		tpm2.HandleOwner, emptyPassword, 0)
}

// GenerateEKey generates the ek key by tpm2, gets the handle and public part
func GenerateEKey() error {
	var err error
	if tpmRef == nil {
		return ErrFailTPMInit
	}
	// for TPM chip, maybe need to load EKParams from NVRAM to create the
	// same EK as the saved EC in NVRAM, need to test!!!
	tpmRef.ek.handle, tpmRef.ek.pub, err = tpm2.CreatePrimary(tpmRef.dev,
		tpm2.HandleEndorsement, pcrSelectionNil,
		emptyPassword, emptyPassword, EKParams)
	if err != nil {
		tpmRef.ek.handle = tpmutil.Handle(0)
		tpmRef.ek.pub = nil
		return err
	}
	return nil
}

// GenerateIKey generates the ik key as a primary key by tpm2, gets the handle, public
// and name fields to use later
func GenerateIKey() error {
	var err error
	if tpmRef == nil {
		return ErrFailTPMInit
	}
	tpmRef.ik.handle, tpmRef.ik.pub, err = tpm2.CreatePrimary(tpmRef.dev,
		tpm2.HandleEndorsement, pcrSelectionNil,
		emptyPassword, emptyPassword, IKParams)
	if err != nil {
		tpmRef.ik.handle = tpmutil.Handle(0)
		tpmRef.ik.pub = nil
		return err
	}
	_, ikName, _, err := tpm2.ReadPublic(tpmRef.dev, tpmRef.ik.handle)
	if err != nil {
		return err
	}
	tpmRef.ik.password = emptyPassword
	tpmRef.ik.name = ikName
	return nil
}

// ActivateIKCert decrypts the IkCert from the input, and return it in PEM format
func ActivateIKCert(in *IKCertInput) ([]byte, error) {
	if tpmRef == nil {
		return nil, ErrFailTPMInit
	}
	sessHandle, _, err := tpm2.StartAuthSession(tpmRef.dev, tpm2.HandleNull, tpm2.HandleNull, make([]byte, 16),
		nil, tpm2.SessionPolicy, tpm2.AlgNull, tpm2.AlgSHA256)
	if err != nil {
		return nil, errors.New("StartAuthSession() failed, error:" + err.Error())
	}
	defer tpm2.FlushContext(tpmRef.dev, sessHandle)

	if _, err = tpm2.PolicySecret(tpmRef.dev, tpm2.HandleEndorsement,
		tpm2.AuthCommand{Session: tpm2.HandlePasswordSession, Attributes: tpm2.AttrContinueSession},
		sessHandle, nil, nil, nil, 0); err != nil {
		return nil, errors.New("PolicySecret() failed, error:" + err.Error())
	}

	recoveredCredential, err := tpm2.ActivateCredentialUsingAuth(tpmRef.dev, []tpm2.AuthCommand{
		{Session: tpm2.HandlePasswordSession, Attributes: tpm2.AttrContinueSession, Auth: []byte(emptyPassword)},
		{Session: sessHandle, Attributes: tpm2.AttrContinueSession, Auth: []byte(emptyPassword)},
	}, tpmRef.ik.handle, tpmRef.ek.handle, in.CredBlob, in.EncryptedSecret)
	if err != nil {
		return nil, errors.New("ActivateCredentialWithAuth error:" + err.Error())
	}
	var alg, mode uint16
	switch in.DecryptAlg {
	case cryptotools.Encrypt_Alg: //AES128_CBC
		alg, mode = cryptotools.AlgAES, cryptotools.AlgCBC
	default:
		return nil, err
	}
	IKCert, err := cryptotools.SymmetricDecrypt(alg, mode,
		recoveredCredential, in.DecryptParam, in.EncryptedCert)
	if err != nil {
		return nil, err
	}
	return IKCert, nil
}

// GetClientInfo returns json format client information.
// TODO: add some other information
func GetClientInfo() (string, error) {
	var err error
	var out0 bytes.Buffer
	var out1 bytes.Buffer
	var out2 bytes.Buffer
	if tpmRef == nil {
		return "", ErrFailTPMInit
	}
	if tpmRef.useHW {
		// execute dmidecode shell-commands to acquire information
		// remind: need sudo permission
		cmd0 := exec.Command("dmidecode", "-t", "0")
		cmd0.Stdout = &out0
		if err = cmd0.Run(); err != nil {
			return "", err
		}
		cmd1 := exec.Command("dmidecode", "-t", "1")
		cmd1.Stdout = &out1
		if err = cmd1.Run(); err != nil {
			return "", err
		}
	} else {
		out0.WriteString(constDMIBIOS)
		out1.WriteString(constDMISYSTEM)
	}
	cmd2 := exec.Command("uname", "-a")
	cmd2.Stdout = &out2
	if err = cmd2.Run(); err != nil {
		return "", err
	}
	clientInfo := map[string]string{}
	start0 := strings.Index(out0.String(), "BIOS Information")
	start1 := strings.Index(out1.String(), "System Information")
	clientInfo["bios"] = out0.String()[start0:]
	clientInfo["system"] = out1.String()[start1:]
	clientInfo["os"] = out2.String()
	clientInfo["ip"] = typdefs.GetIP()
	clientInfo["version"] = "1.1.2"
	strCI, err := json.Marshal(clientInfo)
	return string(strCI), err
}

func readPcrLog(pcrSelection tpm2.PCRSelection) ([]byte, error) {
	var buf bytes.Buffer
	var digBuf []byte
	switch pcrSelection.Hash {
	case tpm2.AlgSHA1:
		digBuf = make([]byte, typdefs.Sha1DigestLen*2)
	case tpm2.AlgSHA256:
		digBuf = make([]byte, typdefs.Sha256DigestLen*2)
	// TODO: need rewrite
	case AlgSM3:
		digBuf = make([]byte, typdefs.SM3DigestLen*2)
	}
	numPCRs := len(pcrSelection.PCRs)
	// read pcr one by one by ordering
	for i := 0; i < numPCRs; i++ {
		pcrSel := tpm2.PCRSelection{
			Hash: pcrSelection.Hash,
			PCRs: []int{i},
		}
		// Ask the TPM for those PCR values.
		ret, err := tpm2.ReadPCRs(tpmRef.dev, pcrSel)
		if err != nil {
			return nil, err
		}
		// Keep track of the PCRs we were actually given.
		for pcr, digest := range ret {
			hex.Encode(digBuf, digest)
			buf.Write(digBuf)
			switch pcrSelection.Hash {
			case tpm2.AlgSHA1:
				buf.WriteString(fmt.Sprintf(" sha1 %02d\n", pcr))
			case tpm2.AlgSHA256:
				buf.WriteString(fmt.Sprintf(" sha256 %02d\n", pcr))
			case AlgSM3:
				buf.WriteString(fmt.Sprintf(" sm3 %02d\n", pcr))
			}
		}
	}
	return buf.Bytes(), nil
}

// GetTrustReport takes a nonce input, generates the current trust report
func GetTrustReport(
	clientID int64,
	nonce uint64,
	algStr string,
	taTestMode bool,
	qcaserver string) (*typdefs.TrustReport, error) {
	if tpmRef == nil {
		return nil, ErrFailTPMInit
	}
	clientInfo, err := GetClientInfo()
	if err != nil {
		return nil, err
	}
	tRepIn := typdefs.TrustReportInput{
		ClientID:   clientID,
		Nonce:      nonce,
		ClientInfo: clientInfo,
	}
	//we use TrustReportIn as user data of Quote to guarantee its integrity
	repHash, err := tRepIn.Hash(algStr)
	if err != nil {
		return nil, err
	}
	quoted, signature, err := tpm2.Quote(tpmRef.dev,
		tpmRef.ik.handle, tpmRef.ik.password, emptyPassword,
		repHash, pcrSelectionAll, tpm2.AlgNull)
	if err != nil {
		return nil, err
	}
	jsonSignature, err := json.Marshal(signature)
	if err != nil {
		return nil, err
	}
	pcrLog, err := readPcrLog(pcrSelectionAll)
	if err != nil {
		return nil, err
	}
	biosLog, err := ioutil.ReadFile(tpmRef.config.BIOSLogPath)
	if err != nil {
		return nil, err
	}
	imaLog, err := ioutil.ReadFile(tpmRef.config.IMALogPath)
	if err != nil {
		return nil, err
	}
	report := typdefs.TrustReport{
		ClientID:   tRepIn.ClientID,
		Nonce:      tRepIn.Nonce,
		ClientInfo: tRepIn.ClientInfo,
		Quoted:     quoted,
		Signature:  jsonSignature,
		Manifests: []typdefs.Manifest{
			{Key: typdefs.StrPcr, Value: pcrLog},
			{Key: typdefs.StrBios, Value: biosLog},
			{Key: typdefs.StrIma, Value: imaLog},
		},
	}

	taReports, err := buildTaReport(nonce, qcaserver, taTestMode)
	if err != nil {
		return nil, err
	}
	report.TaReports = taReports

	return &report, nil
}

func buildTaReport(nonce uint64, qcaserver string, taTestMode bool) (map[string][]byte, error) {
	taReports := map[string][]byte{}
	if !taTestMode {
		talist, err := ioutil.ReadFile(talistpath)
		if err != nil {
			return nil, err
		}
		lines := bytes.Split(talist, typdefs.NewLine)
		for _, ln := range lines {
			//words[0]是uuid words[1]是with_tcb
			words := bytes.Split(ln, typdefs.Space)
			with_tcb := true
			if string(words[1]) == strfalse {
				with_tcb = false
			}
			//convert uint64 to []byte
			bytesBuffer := bytes.NewBuffer([]byte{})
			binary.Write(bytesBuffer, binary.LittleEndian, nonce)
			taReport, err := getTaReport(words[0], bytesBuffer.Bytes(), with_tcb, qcaserver)
			if err != nil {
				return nil, err
			}
			taReports[string(words[0])] = taReport
		}
	} else {
		taReports[uuid1] = taReport1
	}
	return taReports, nil
}

// remote invoke qca api to get the TA's info
func getTaReport(uuid []byte, nonce []byte, with_tcb bool, server string) ([]byte, error) {
	reqID := qapi.GetReportRequest{
		Uuid:    uuid,
		Nonce:   nonce,
		WithTcb: with_tcb,
	}

	rpyID, err := qapi.DoGetTeeReport(server, &reqID)
	if err != nil {
		log.Printf("Get TA infomation failed, error: %v", err)
		return nil, err
	}
	log.Print("Get TA report succeeded!")

	return rpyID.GetTeeReport(), nil
}

func getManifest(imaPath, biosPath string) ([]typdefs.Manifest, error) {
	var manifest []typdefs.Manifest
	f, err := ioutil.ReadFile(imaPath)
	if err == nil {
		manifest = append(manifest, typdefs.Manifest{Key: "ima", Value: f})
	}

	f, err = ioutil.ReadFile(biosPath)
	if err == nil {
		manifest = append(manifest, typdefs.Manifest{Key: "bios", Value: f})
	}

	return manifest, err
}

// PreparePCRsTest method replay the bios/ima manifests into pcrs in test mode.
func PreparePCRsTest() error {
	if tpmRef.useHW {
		return nil
	}
	pcrs := typdefs.NewPcrGroups()
	// read the manifest files into memory
	manifest, err := getManifest(tpmRef.config.IMALogPath, tpmRef.config.BIOSLogPath)
	if err != nil {
		return err
	}

	// replay bios manifest
	biosContent := getManifestContent(manifest, typdefs.StrBios)
	if biosContent != nil {
		replayBIOSManifestTest(pcrs, biosContent)
	}
	// replay ima manifest
	imaContent := getManifestContent(manifest, typdefs.StrIma)
	if imaContent != nil {
		replayIMAManifestTest(pcrs, imaContent)
	}

	return nil
}

func getManifestContent(ms []typdefs.Manifest, t string) []byte {
	for _, m := range ms {
		if m.Key == t {
			return m.Value
		}
	}
	return nil
}

func replayBIOSManifestTest(pcrs *typdefs.PcrGroups, content []byte) error {
	//use bios manifest to replay pcrs
	btLog, _ := typdefs.TransformBIOSBinLogToTxt(content)
	typdefs.ExtendPCRWithBIOSTxtLog(pcrs, btLog)
	algID := algIdMap[tpmRef.config.ReportHashAlg]
	var v [24][]byte
	switch tpmRef.config.ReportHashAlg {
	case typdefs.Sha1AlgStr:
		v = pcrs.Sha1Pcrs
	case typdefs.Sha256AlgStr:
		v = pcrs.Sha256Pcrs
	case typdefs.Sm3AlgStr:
		v = pcrs.SM3Pcrs
	}
	for i := 0; i < typdefs.PcrMaxNum; i++ {
		tpm2.PCRExtend(tpmRef.dev, tpmutil.Handle(i), algID, v[i], emptyPassword)
	}

	return nil
}

func replayIMAManifestTest(pcrs *typdefs.PcrGroups, content []byte) error {
	//use ima manifest to replay pcrs
	typdefs.ExtendPCRWithIMALog(pcrs, content, tpmRef.config.ReportHashAlg)
	algID := algIdMap[tpmRef.config.ReportHashAlg]
	var v [24][]byte
	switch tpmRef.config.ReportHashAlg {
	case typdefs.Sha1AlgStr:
		v = pcrs.Sha1Pcrs
	case typdefs.Sha256AlgStr:
		v = pcrs.Sha256Pcrs
	case typdefs.Sm3AlgStr:
		v = pcrs.SM3Pcrs
	}
	for i := 0; i < typdefs.PcrMaxNum; i++ {
		tpm2.PCRExtend(tpmRef.dev, tpmutil.Handle(i), algID, v[i], emptyPassword)
	}

	return nil
}
