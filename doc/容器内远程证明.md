## 整体流程
相比于主机上的远程证明，容器内远程证明增加了容器内运行的qca_daemon, libqca_report, qta_report，新增组件在容器中运行，可获取且只能本容器内ta的远程证明。
整体的细节如下：
1. 启动as server，用于在有as服务场景下，对tee派生的AK密钥做签名。
2. 启动ra server, 指定模式，调用libqca/qta在tee内生成ak密钥，若有as场景下，连接as server完成密钥的签名，并保存到tee。
3. 启动容器，并在容器内启动qca_daemon, 其会与ra server建立连接，并注册自己的容器id。
4. ra client发起挑战，指定容器信息表明获取容器内ta的度量报告，ra server接收到请求后，识别请求中的容器信息，无则认为是主机ta，走原逻辑，是走如下逻辑：
  > 1. 获取容器在主机上对应的pid和nsid(命名空间)，
  > 2. 调用libqca将容器id和nsid注册到qta中。
  > 3. 将请求转发到容器里的qca_daemon，
  > 4. qca_daemon调用libqca_report调用qta-report获取度量报告，（qta_report会自动向主机的qta验证容器id和nsid）
  > 5. 获取到度量报告后，转发给主机上的ra server.
5. ra server将度量报告返回给ra client.
6. ra client调用libteeverifier.so完成度量报告的验证。如果度量报告中有容器信息，则会自动验证容器信息和qta_report的度量值。



## 配置：
### ra_client: 
在原基础上增加ta运行的容器的id和type，以及qta_report的基准度量
1. yaml配置文件修改，如果未配置则默认ta运行在主机上
```yaml
attesterconfig:
  ....
  virtualguest:
    id: xxxxx(64)   # 运行ta的目标容器id， 64位
    type: docker    # 运行ta的目标容器type， 目前只支持docker
```
也可在命令行中指定
```shell
--id xxxx  #指定容器id
--type xxx #指定容器类型 
```
2. basevalue.txt文件修改
```txt
.....
qta_report_uuid img_hash mem_hash 
```

### ra_server
需要在命令行中指明是否支持容器，在原基础上增加用于监听容器请求的服务端的地址配置和容器socket连接的健康检查，
1. 命令行支持
```shell
-V true   # 支持虚拟化容器远程证明。
-A xxxxx  # 用于接收容器请求的socket地址 ip:port
-H 10     # socket连接健康检查周期，单位分钟
```
2. yaml配置文件
```yaml
qcaconfig:
  ...
  virtual:
    server: 0.0.0.0:90000
    healthcheck: 10  # minute, <0 no health check, max is 7 day
```

### qca_daemon
1. 支持命令行指定host侧监听服务端地址
```shell
-H ip:port    # 容器可填写docker0的ip地址
```

## 使用
基本方式同特性指南中主机上的远程证明。增加的配置按如上配置。
0. 编译
```shell
cd kunpengsecl
make clean;make build
cp attestation/tee/tverlib/verifier/libteeverifier.so /usr/lib64
```
1. 启动ra_server
```shell
cd attestation/tee/demo/qca_demon/cmd
cp ../../pkg/qcaserver /vendor/bin
/vendor/bin/qcaserver -C 0 -V true -A 0.0.0.0:9000
```
2. 启动容器内qca_daemon
```shell
cp attestation/tee/demo/pkg/qca_daemon /vendor/bin
/vendor/bin/qca_daemon -H 172.17.0.1:9000
```
3. ra_client发起挑战，配置好容器信息。
```shell
cd attestation/tee/demo/attester_demo/cmd
go run main.go
```
